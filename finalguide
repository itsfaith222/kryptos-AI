Guardian AI
20-Hour ELLEHacks 2026 Build Plan
4 AI Agents | Email/Message Scanning | Privacy Shield | Predictive Protection
Team of 4 | One Agent Per Person | Everyone Gets AI Experience
‚ÄÉ
‚ö†Ô∏è SECURITY PILLAR ONLY - NO OVERLAP ‚ö†Ô∏è
CRITICAL: Theme Alignment
Guardian AI = SECURITY pillar ONLY
‚Ä¢	‚úÖ Email/message scanning = Security threat detection
‚Ä¢	‚úÖ Privacy policy analysis = Security transparency
‚Ä¢	‚úÖ Education = Security awareness (NOT empowerment)
‚Ä¢	‚úÖ Voice alerts = Security feature (NOT accessibility pillar)

‚úÖ SAY: "Protecting users from scams and privacy violations through real-time threat detection"
‚ùå DON'T SAY: "Empowering through education" or "Accessibility for disabled users"
‚ÄÉ
Table of Contents
1.	Project Overview & Unique Features
2.	The 4 AI Agents (Detailed Breakdown)
3.	Team Split: One Agent Per Person (Option 1)
4.	Tech Stack & Tools Per Person
5.	Repository Structure & File Ownership
6.	Git Workflow for 4-Person Team
7.	Integration Strategy & Contracts
8.	20-Hour Timeline with Milestones
9.	API Design & Data Contracts
10.	How to Avoid Merge Conflicts
11.	Demo Script (90 seconds)
12.	Winning Strategy & Prizes
‚ÄÉ
1. Project Overview & Unique Features
What You're Building
Guardian AI is a Chrome extension powered by 4 AI agents that scans emails, messages, and web pages in real-time to protect users from phishing, scams, and privacy violations - with predictive intelligence that warns you BEFORE threats appear.
The 3 Unique Features ‚≠ê
1. Email/Message Scanning (NEW!)
‚Ä¢	Paste any suspicious email/text ‚Üí instant scam analysis
‚Ä¢	Screenshot upload ‚Üí OCR extracts text + analyzes embedded images
‚Ä¢	Link hover intelligence ‚Üí shows safety rating tooltip
‚Ä¢	Real-time monitoring of incoming communications
2. Privacy Policy Auto-Analyzer (NEW!)
‚Ä¢	Auto-detects Terms & Conditions pages
‚Ä¢	Extracts what data they collect, who sees it, can you delete it
‚Ä¢	Shows in plain English: "This app sells your location to 400+ advertisers"
‚Ä¢	Privacy severity score (0-100)
3. Predictive Protection (NEW!)
‚Ä¢	Learns your behavior patterns (privacy-friendly)
‚Ä¢	Checks trending scams in MongoDB
‚Ä¢	Proactive warnings: "Fake Netflix scams trending in your area"
‚Ä¢	Demographic matching: "Users like you being targeted by X"
‚ÄÉ
2. The 4 AI Agents (Detailed Breakdown)
üîç AGENT 1: SCOUT (Detector & Monitor)
Location: Chrome Extension + Backend (/backend/agents/scout.py)
Main Functions:
‚Ä¢	Email/Message Scanning - monitors incoming communications
‚Ä¢	Message Paste Analysis - user pastes text ‚Üí instant scan
‚Ä¢	Link Hover Intelligence - mouse hover ‚Üí safety tooltip
‚Ä¢	Screenshot Upload - OCR + image analysis
‚Ä¢	Web Page Detection - login pages, privacy policies, forms
‚Ä¢	Predictive Pattern Learning - queries trending threats from MongoDB
Scout Tools & Technologies:
‚Ä¢	Chrome Extension APIs (Tabs, Storage, WebRequest)
‚Ä¢	JavaScript libraries (DOMPurify, TLD.js)
‚Ä¢	MongoDB queries (blacklist lookups, trending threats)
‚Ä¢	Local Storage (user behavior cache)
‚Ä¢	Gemini Vision API (image/screenshot analysis)
‚Ä¢	Python backend logic
Scout Output Example:
{
  "scanType": "email" | "url" | "page" | "message" | "image",
  "initialRisk": 0-100,
  "signals": {
    "hasPassword": true,
    "urgencyWords": ["urgent", "verify"],
    "domainAge": "2 days",
    "suspiciousImages": true
  },
  "predictiveWarning": "Fake Netflix scams trending",
  "recommendation": "ESCALATE_TO_ANALYST" | "SAFE" | "BLOCK"
}
‚ÄÉ
üß† AGENT 2: ANALYST (Deep Investigator)
Location: Backend only (/backend/agents/analyst.py)
Main Functions:
‚Ä¢	Multi-Source Intelligence - web search, MongoDB, WHOIS
‚Ä¢	Deep Content Analysis - Gemini context understanding
‚Ä¢	Psychological Manipulation Detection - maps to MITRE ATT&CK
‚Ä¢	Privacy Policy Deep Dive - extracts data practices
‚Ä¢	Risk Scoring & Classification - evidence weighting
MITRE ATT&CK Integration:
‚Ä¢	Maps scam tactics to standardized threat techniques
‚Ä¢	Urgency ‚Üí T1566.002 (Spearphishing Link)
‚Ä¢	Authority impersonation ‚Üí T1598.003 (Phishing for Info)
‚Ä¢	Fear tactics ‚Üí T1534 (Internal Spearphishing)
‚Ä¢	Professional logging + reporting capability
Analyst Tools & Technologies:
‚Ä¢	Gemini 2.0 Flash API (text analysis)
‚Ä¢	Gemini Vision API (logo detection)
‚Ä¢	Web search APIs (optional)
‚Ä¢	WHOIS APIs (domain investigation)
‚Ä¢	MongoDB aggregation (pattern matching)
‚Ä¢	Python NLP libraries
Analyst Output Example:
{
  "analysisId": "abc123",
  "threatType": "phishing",
  "riskScore": 87,
  "confidence": 0.92,
  "mitreAttackTechniques": ["T1566.002", "T1598.003"],
  "evidence": [
    {
      "type": "domain",
      "finding": "Domain created 2 days ago",
      "weight": 0.8,
      "severity": "high"
    }
  ]
}
‚ÄÉ
üë®‚Äçüè´ AGENT 3: EDUCATOR (Explainer)
Location: Backend only (/backend/agents/educator.py)
Main Functions:
‚Ä¢	Plain English Translation - converts technical findings
‚Ä¢	Privacy Breakdown - What/Who/Can Delete format
‚Ä¢	Personalized Learning - tracks scams you've seen
‚Ä¢	Multilingual Support - 50+ languages via Gemini
‚Ä¢	Voice Output - ElevenLabs text-to-speech
Educator Tools & Technologies:
‚Ä¢	Gemini API (multilingual generation)
‚Ä¢	ElevenLabs API (text-to-speech)
‚Ä¢	MongoDB (user learning history)
‚Ä¢	Python template generation
Educator Output Example:
üö® PRIVACY ALERT - HIGH RISK

This app wants A LOT of your data:

‚ùå WHAT THEY TAKE:
‚Ä¢ Your exact location 24/7
‚Ä¢ Who you text and call
‚Ä¢ Your browsing history

‚ö†Ô∏è WHO SEES IT:
‚Ä¢ 400+ advertising companies
‚Ä¢ Data brokers who sell it

üîí CAN YOU DELETE IT?
‚Ä¢ NO - They keep it forever

üí° Don't accept these terms.
‚ÄÉ
üß© AGENT 4: ORCHESTRATOR (The Brain)
Location: FastAPI Backend (/backend/main.py) + React Dashboard (/webapp/)
Main Functions:
‚Ä¢	Agent Coordination - routes tasks to Scout/Analyst/Educator
‚Ä¢	Real-Time Alerts - WebSocket push notifications
‚Ä¢	Predictive Intelligence - trending threat analysis
‚Ä¢	Impact Dashboard - live stats and visualizations
‚Ä¢	Rate Limiting - manages Gemini API calls
‚Ä¢	MongoDB Schema - database structure
Orchestrator Tools & Technologies:
‚Ä¢	FastAPI (Python web framework)
‚Ä¢	MongoDB + pymongo
‚Ä¢	Socket.IO (WebSockets)
‚Ä¢	React 18 + Vite
‚Ä¢	TailwindCSS + Recharts
‚Ä¢	Framer Motion (animations)
‚ÄÉ
3. Team Split: One Agent Per Person (Option 1)
‚≠ê THIS IS THE RECOMMENDED SPLIT - EVERYONE GETS AI EXPERIENCE ‚≠ê
Why This Split Works Best
‚Ä¢	‚úÖ Everyone learns AI/Gemini API
‚Ä¢	‚úÖ Everyone touches Python backend
‚Ä¢	‚úÖ Balanced workload (18-20 hours each)
‚Ä¢	‚úÖ Clear ownership = fewer merge conflicts
‚Ä¢	‚úÖ Can test agents independently
‚Ä¢	‚úÖ Better for portfolios/learning
‚Ä¢	‚úÖ Full-stack exposure for all
‚ÄÉ
Person A: Scout Agent Owner
Full Ownership: Extension + Scout Backend Agent
Responsibilities:
‚Ä¢	Build entire Chrome extension (UI + logic)
‚Ä¢	Implement email/message paste scanning
‚Ä¢	Screenshot upload + OCR integration
‚Ä¢	Link hover tooltips with safety ratings
‚Ä¢	Page detection logic (login, privacy policies)
‚Ä¢	Scout backend agent in Python
‚Ä¢	MongoDB queries for predictive warnings
Technologies Person A Uses:
‚Ä¢	Chrome Extension APIs (JavaScript)
‚Ä¢	HTML/CSS for popup UI
‚Ä¢	Python (Scout backend agent)
‚Ä¢	Gemini Vision API (screenshot analysis)
‚Ä¢	MongoDB (predictive threat queries)
‚Ä¢	TailwindCSS (extension styling)
Files Person A Owns:
/extension/
  ‚îú‚îÄ‚îÄ manifest.json          ‚Üê Person A
  ‚îú‚îÄ‚îÄ content.js             ‚Üê Person A
  ‚îú‚îÄ‚îÄ background.js          ‚Üê Person A
  ‚îú‚îÄ‚îÄ popup.html             ‚Üê Person A
  ‚îú‚îÄ‚îÄ popup.js               ‚Üê Person A
  ‚îî‚îÄ‚îÄ styles.css             ‚Üê Person A

/backend/agents/
  ‚îî‚îÄ‚îÄ scout.py               ‚Üê Person A
Git Branch:
feature/scout-agent
Estimated Hours:
18-20 hours
‚ÄÉ
Person B: Analyst Agent Owner
Full Ownership: Analyst Backend Agent
Responsibilities:
‚Ä¢	Implement Analyst agent (deep investigation)
‚Ä¢	Gemini API integration (threat analysis)
‚Ä¢	MITRE ATT&CK framework mapping
‚Ä¢	Privacy policy extraction with Gemini
‚Ä¢	Evidence weighting system
‚Ä¢	WHOIS domain investigation
‚Ä¢	Risk scoring algorithms
Technologies Person B Uses:
‚Ä¢	Python (backend agent)
‚Ä¢	Gemini 2.0 Flash API (text analysis)
‚Ä¢	Gemini Vision API (logo detection)
‚Ä¢	WHOIS APIs (domain data)
‚Ä¢	MongoDB (pattern matching)
‚Ä¢	NLP libraries (sentiment analysis)
Files Person B Owns:
/backend/agents/
  ‚îî‚îÄ‚îÄ analyst.py             ‚Üê Person B
Git Branch:
feature/analyst-agent
Estimated Hours:
18-20 hours (highest complexity)
‚ÄÉ
Person C: Educator Agent Owner
Full Ownership: Educator Backend Agent
Responsibilities:
‚Ä¢	Implement Educator agent (plain English generation)
‚Ä¢	Gemini API prompts for explanations
‚Ä¢	Privacy breakdown formatter (What/Who/Delete)
‚Ä¢	Multilingual support (50+ languages)
‚Ä¢	ElevenLabs voice integration
‚Ä¢	Learning gamification logic
‚Ä¢	User-friendly content generation
Technologies Person C Uses:
‚Ä¢	Python (backend agent)
‚Ä¢	Gemini API (multilingual generation)
‚Ä¢	ElevenLabs API (text-to-speech)
‚Ä¢	MongoDB (user learning history)
‚Ä¢	Template generation libraries
Files Person C Owns:
/backend/agents/
  ‚îî‚îÄ‚îÄ educator.py            ‚Üê Person C
Git Branch:
feature/educator-agent
Estimated Hours:
18-20 hours
‚ÄÉ
Person D: Orchestrator + Dashboard Owner
Full Ownership: Backend Infrastructure + All Frontend UI
Responsibilities:
‚Ä¢	FastAPI server setup + routing
‚Ä¢	MongoDB schema design
‚Ä¢	WebSocket server (Socket.IO)
‚Ä¢	Agent orchestration logic
‚Ä¢	Rate limiting for Gemini API
‚Ä¢	Entire React dashboard UI
‚Ä¢	Real-time toast notifications
‚Ä¢	Charts and visualizations
Technologies Person D Uses:
‚Ä¢	Python + FastAPI (backend)
‚Ä¢	MongoDB + pymongo
‚Ä¢	Socket.IO (WebSockets)
‚Ä¢	React 18 + Vite
‚Ä¢	TailwindCSS
‚Ä¢	Recharts (charts)
‚Ä¢	Framer Motion (animations)
‚Ä¢	React Hot Toast
Files Person D Owns:
/backend/
  ‚îú‚îÄ‚îÄ main.py                ‚Üê Person D (orchestrator)
  ‚îú‚îÄ‚îÄ database.py            ‚Üê Person D (MongoDB)
  ‚îî‚îÄ‚îÄ requirements.txt       ‚Üê Person D (manages)

/webapp/                     ‚Üê Person D (entire folder)
  ‚îú‚îÄ‚îÄ src/
  ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
  ‚îÇ   ‚îú‚îÄ‚îÄ components/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.jsx
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PrivacyAlert.jsx
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StatCard.jsx
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ScanModal.jsx
  ‚îÇ   ‚îî‚îÄ‚îÄ utils/
  ‚îÇ       ‚îú‚îÄ‚îÄ socket.js
  ‚îÇ       ‚îî‚îÄ‚îÄ api.js
  ‚îî‚îÄ‚îÄ package.json
Git Branch:
feature/orchestrator-dashboard
Estimated Hours:
18-20 hours (infrastructure + UI)
‚ÄÉ
Workload Comparison Table
BALANCED WORKLOAD:

Person A: Extension (Frontend) + Scout (Backend)
- Chrome extension UI and logic
- Scout backend agent
- Gemini Vision API
- MongoDB queries
= 18-20 hours | Medium-High complexity

Person B: Analyst Agent (Backend)
- Threat analysis with Gemini
- MITRE ATT&CK mapping
- Privacy policy extraction
- Evidence weighting
= 18-20 hours | High complexity (most AI work)

Person C: Educator Agent (Backend)
- Plain English generation
- Multilingual support
- Voice integration
- Gamification
= 18-20 hours | Medium complexity

Person D: Orchestrator + Dashboard
- FastAPI infrastructure
- MongoDB schema
- WebSocket server
- Entire React dashboard
= 18-20 hours | High complexity (most integration)

‚úÖ EVERYONE GETS:
- Gemini API experience (A, B, C all use it)
- Python backend experience (all 4)
- MongoDB experience (A and D)
- Full ownership of their component
‚ÄÉ
5. Repository Structure & File Ownership
Complete File Structure
guardian-ai/
‚îú‚îÄ‚îÄ README.md                     ‚Üê SHARED (Person D writes)
‚îú‚îÄ‚îÄ .gitignore                    ‚Üê SHARED
‚îÇ
‚îú‚îÄ‚îÄ extension/                    ‚Üê PERSON A OWNS ALL
‚îÇ   ‚îú‚îÄ‚îÄ manifest.json
‚îÇ   ‚îú‚îÄ‚îÄ content.js               (DOM analysis, paste scanning)
‚îÇ   ‚îú‚îÄ‚îÄ background.js            (service worker, monitoring)
‚îÇ   ‚îú‚îÄ‚îÄ popup.html
‚îÇ   ‚îú‚îÄ‚îÄ popup.js                 (UI logic)
‚îÇ   ‚îî‚îÄ‚îÄ styles.css
‚îÇ
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                   ‚Üê PERSON D (orchestrator)
‚îÇ   ‚îú‚îÄ‚îÄ database.py               ‚Üê PERSON D (MongoDB schema)
‚îÇ   ‚îú‚îÄ‚îÄ contracts.py              ‚Üê SHARED (read-only after Hour 1)
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt          ‚Üê PERSON D (manages)
‚îÇ   ‚îú‚îÄ‚îÄ .env                      ‚Üê SHARED (API keys)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ agents/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py           ‚Üê SHARED
‚îÇ       ‚îú‚îÄ‚îÄ scout.py              ‚Üê PERSON A
‚îÇ       ‚îú‚îÄ‚îÄ analyst.py            ‚Üê PERSON B
‚îÇ       ‚îî‚îÄ‚îÄ educator.py           ‚Üê PERSON C
‚îÇ
‚îî‚îÄ‚îÄ webapp/                       ‚Üê PERSON D OWNS ALL
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ vite.config.js
    ‚îú‚îÄ‚îÄ tailwind.config.js
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
    ‚îÇ   ‚îú‚îÄ‚îÄ main.jsx
    ‚îÇ   ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.jsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PrivacyAlert.jsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StatCard.jsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ScanModal.jsx
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RecentScans.jsx
    ‚îÇ   ‚îî‚îÄ‚îÄ utils/
    ‚îÇ       ‚îú‚îÄ‚îÄ socket.js        (WebSocket client)
    ‚îÇ       ‚îî‚îÄ‚îÄ api.js           (API calls)
    ‚îî‚îÄ‚îÄ public/
File Ownership Rules
‚Ä¢	‚úÖ Person A: ONLY touches /extension/ and /backend/agents/scout.py
‚Ä¢	‚úÖ Person B: ONLY touches /backend/agents/analyst.py
‚Ä¢	‚úÖ Person C: ONLY touches /backend/agents/educator.py
‚Ä¢	‚úÖ Person D: ONLY touches /backend/main.py, database.py, and /webapp/
Shared Files (Read-Only After Hour 1)
‚Ä¢	contracts.py - Data structure definitions (NOBODY edits after Hour 1)
‚Ä¢	.env - API keys (add keys, don't change format)
‚Ä¢	requirements.txt - Person D manages, others can request additions
‚Ä¢	README.md - Person D writes final version
‚ÄÉ
6. Git Workflow for 4-Person Team
Branch Strategy
‚Ä¢	main - Protected, demo-ready code only
‚Ä¢	dev - Integration branch (merge here first)
‚Ä¢	feature/scout-agent - Person A
‚Ä¢	feature/analyst-agent - Person B
‚Ä¢	feature/educator-agent - Person C
‚Ä¢	feature/orchestrator-dashboard - Person D
Initial Setup (Hour 0)
# Person D creates repo and initial structure
git init
git add README.md .gitignore
git commit -m "Initial commit"
git branch -M main
git remote add origin https://github.com/your-team/guardian-ai.git
git push -u origin main

# Person D creates dev branch
git checkout -b dev
git push -u origin dev

# Everyone clones
git clone https://github.com/your-team/guardian-ai.git
cd guardian-ai

# Each person creates their branch FROM dev
git checkout dev
git checkout -b feature/scout-agent        # Person A
git checkout -b feature/analyst-agent      # Person B
git checkout -b feature/educator-agent     # Person C
git checkout -b feature/orchestrator       # Person D
Daily Workflow (Each Person)
# Morning: Pull latest changes
git checkout dev
git pull origin dev
git checkout feature/your-branch
git merge dev

# Work on your files
# (Edit only YOUR files)

# Commit frequently
git add .
git commit -m "feat: add email paste scanning to Scout"

# Push to your branch
git push origin feature/your-branch

# Create Pull Request to dev
# (On GitHub: feature/your-branch ‚Üí dev)

# After PR approved and merged, pull latest
git checkout dev
git pull origin dev
Integration Points (Hours 6, 12, 16)
# Person D coordinates integration

HOUR 6 - First Integration:
1. Everyone creates PR to dev
2. Person D reviews and merges all PRs
3. Everyone pulls latest dev
4. Test together: Does extension ‚Üí backend ‚Üí dashboard work?
5. Fix any breaking issues immediately

HOUR 12 - Second Integration:
1. Everyone merges latest work to dev
2. Test with real Gemini API calls
3. Verify all agents communicate properly
4. Fix integration bugs

HOUR 16 - Final Integration:
1. Merge all final features to dev
2. Full end-to-end testing
3. Merge dev ‚Üí main
4. Deploy for demo
‚ÄÉ
7. Integration Strategy & Contracts
The Contract System (Critical!)
To avoid conflicts, everyone agrees on data structures in Hour 0 and NEVER changes them without team discussion.
contracts.py - The Sacred File
"""
Guardian AI - Data Contracts
CRITICAL: Do NOT edit this file after Hour 1 without team agreement!
"""
from typing import Optional, List, Dict
from pydantic import BaseModel

# Input to Scout
class ScanInput(BaseModel):
    url: str
    scanType: str  # "page" | "email" | "message" | "image"
    content: Optional[str] = None
    image_data: Optional[str] = None  # base64 for screenshots

# Output from Scout ‚Üí Input to Analyst
class ScoutOutput(BaseModel):
    scanType: str
    initialRisk: int  # 0-100
    signals: Dict
    recommendation: str  # "ESCALATE_TO_ANALYST" | "SAFE" | "BLOCK"
    predictiveWarning: Optional[str] = None

# Output from Analyst ‚Üí Input to Educator
class AnalystOutput(BaseModel):
    analysisId: str
    threatType: str  # "phishing" | "scam" | "malware" | "privacy_violation"
    riskScore: int  # 0-100
    confidence: float  # 0.0-1.0
    evidence: List[Dict]
    mitreAttackTechniques: List[str]

# Output from Educator ‚Üí Final Output
class EducatorOutput(BaseModel):
    explanation: str
    nextSteps: List[str]
    learningPoints: List[str]
    voiceAlert: Optional[str] = None

# Final Combined Output (Person D assembles)
class ScanResult(BaseModel):
    scanId: str
    timestamp: str
    url: str
    scanType: str
    riskScore: int
    threatType: str
    confidence: float
    evidence: List[Dict]
    explanation: str
    nextSteps: List[str]
    mitreAttackTechniques: List[str]
How Agents Communicate
# In Person D's main.py (Orchestrator)

@app.post("/scan")
async def scan_endpoint(input: ScanInput):
    # Step 1: Scout analyzes
    scout_result = await scout_agent.analyze(input)  # Person A's code
    
    # If safe, return early
    if scout_result.recommendation == "SAFE":
        return {"status": "safe", "riskScore": scout_result.initialRisk}
    
    # Step 2: Analyst investigates
    analyst_result = await analyst_agent.investigate(scout_result)  # Person B
    
    # Step 3: Educator explains
    educator_result = await educator_agent.explain(analyst_result)  # Person C
    
    # Step 4: Person D combines and saves
    final_result = ScanResult(
        scanId=generate_id(),
        timestamp=datetime.now(),
        url=input.url,
        scanType=input.scanType,
        riskScore=analyst_result.riskScore,
        threatType=analyst_result.threatType,
        confidence=analyst_result.confidence,
        evidence=analyst_result.evidence,
        explanation=educator_result.explanation,
        nextSteps=educator_result.nextSteps,
        mitreAttackTechniques=analyst_result.mitreAttackTechniques
    )
    
    # Save to MongoDB
    await database.save_scan(final_result)
    
    # Push to WebSocket
    await socketio.emit('new_threat', final_result.dict())
    
    return final_result

AI vs database / threat detection (clarification)
‚Ä¢ Threat classification (what kind of attack, evidence, MITRE mapping, plain-English explanation) is done by AI (OpenRouter ‚Üí Gemini). The AI interprets content and returns threatType, riskScore, evidence, manipulation tactics.
‚Ä¢ MongoDB is used for: (1) storing every scan result, (2) predictive/trending (e.g. ‚Äúscams trending‚Äù from aggregated past scans), (3) blacklist lookups and pattern matching against our own saved data. The guide does not use an external government/threat-intel API; ‚Äúpattern matching‚Äù and ‚Äúblacklist‚Äù refer to your app‚Äôs MongoDB (scans + derived trends), not a preloaded government dataset. So: AI does the content understanding and classification; the database holds our scan history and derived trends for predictive warnings and pattern checks.
 
Development with Mock Data (Hours 0-6)
Each person develops their agent independently with mock data, then integrates at Hour 6.
# Person A (Scout) - Works independently
def analyze(input: ScanInput) -> ScoutOutput:
    # Real implementation
    signals = extract_page_signals(input.url)
    risk = calculate_initial_risk(signals)
    
    return ScoutOutput(
        scanType=input.scanType,
        initialRisk=risk,
        signals=signals,
        recommendation="ESCALATE_TO_ANALYST" if risk > 50 else "SAFE"
    )

# Person B (Analyst) - Tests with mock Scout data
def test_analyst():
    mock_scout_output = ScoutOutput(
        scanType="page",
        initialRisk=75,
        signals={"hasPassword": True, "domainAge": "2 days"},
        recommendation="ESCALATE_TO_ANALYST"
    )
    
    result = analyst_agent.investigate(mock_scout_output)
    print(result)  # Verify output format

# Person C (Educator) - Tests with mock Analyst data
def test_educator():
    mock_analyst_output = AnalystOutput(
        analysisId="test123",
        threatType="phishing",
        riskScore=87,
        confidence=0.92,
        evidence=[...],
        mitreAttackTechniques=["T1566.002"]
    )
    
    result = educator_agent.explain(mock_analyst_output)
    print(result)  # Verify output format

# Hour 6: Person D integrates all three
# Now real data flows through the pipeline!
‚ÄÉ
8. 20-Hour Timeline with Milestones
HOUR 0-1: Setup & Contracts
‚Ä¢	Person D: Create repo, initial structure, contracts.py
‚Ä¢	Person A: Set up extension boilerplate
‚Ä¢	Person B: Set up analyst.py boilerplate
‚Ä¢	Person C: Set up educator.py boilerplate
‚Ä¢	Everyone: Get API keys (Gemini, MongoDB, ElevenLabs)
‚Ä¢	Everyone: Review and agree on contracts.py
‚Ä¢	Everyone: Create feature branches
HOUR 1-6: Independent Development
Person A (Scout):
‚Ä¢	‚úì Extension UI (popup, badge)
‚Ä¢	‚úì Content script (DOM analysis)
‚Ä¢	‚úì Email paste detection
‚Ä¢	‚úì Scout backend with mock data
Person B (Analyst):
‚Ä¢	‚úì Gemini API integration
‚Ä¢	‚úì Basic threat analysis
‚Ä¢	‚úì Evidence extraction
‚Ä¢	‚úì Test with mock Scout data
Person C (Educator):
‚Ä¢	‚úì Gemini prompt for plain English
‚Ä¢	‚úì Privacy breakdown formatter
‚Ä¢	‚úì Test with mock Analyst data
Person D (Orchestrator):
‚Ä¢	‚úì FastAPI server setup
‚Ä¢	‚úì MongoDB connection
‚Ä¢	‚úì Basic React dashboard
‚Ä¢	‚úì Integration logic skeleton
üéØ MILESTONE (Hour 6): Extension badge works, backend responds with mock data
‚ÄÉ
HOUR 6: FIRST INTEGRATION
‚Ä¢	Person D merges all branches to dev
‚Ä¢	Everyone pulls latest dev
‚Ä¢	Test: Extension ‚Üí Scout ‚Üí Analyst ‚Üí Educator ‚Üí Dashboard
‚Ä¢	Fix any breaking issues together
‚Ä¢	Verify contracts are working
HOUR 6-12: Core Features with Real Data
Person A (Scout):
‚Ä¢	‚úì Screenshot upload + OCR
‚Ä¢	‚úì Link hover tooltips
‚Ä¢	‚úì MongoDB predictive queries
‚Ä¢	‚úì Gemini Vision for images
Person B (Analyst):
‚Ä¢	‚úì MITRE ATT&CK mapping
‚Ä¢	‚úì Privacy policy extraction
‚Ä¢	‚úì WHOIS integration
‚Ä¢	‚úì Evidence weighting
Person C (Educator):
‚Ä¢	‚úì Multilingual support
‚Ä¢	‚úì ElevenLabs voice alerts
‚Ä¢	‚úì Learning gamification
Person D (Orchestrator):
‚Ä¢	‚úì WebSocket server
‚Ä¢	‚úì Real-time dashboard updates
‚Ä¢	‚úì Rate limiting
‚Ä¢	‚úì Toast notifications
üéØ MILESTONE (Hour 12): All agents working with real Gemini API, data flowing end-to-end
‚ÄÉ
HOUR 12: SECOND INTEGRATION
‚Ä¢	Everyone merges to dev
‚Ä¢	Full pipeline test with real scam examples
‚Ä¢	Verify privacy policy analyzer works
‚Ä¢	Test WebSocket alerts
‚Ä¢	Fix integration bugs
HOUR 12-16: Polish & Advanced Features
Person A (Scout):
‚Ä¢	‚úì UI polish (animations, loading states)
‚Ä¢	‚úì Error handling
‚Ä¢	‚úì Edge cases (no internet, API down)
Person B (Analyst):
‚Ä¢	‚úì Improve accuracy
‚Ä¢	‚úì Add more MITRE techniques
‚Ä¢	‚úì Optimize Gemini prompts
Person C (Educator):
‚Ä¢	‚úì Refine explanations
‚Ä¢	‚úì Add more languages
‚Ä¢	‚úì Polish voice output
Person D (Orchestrator):
‚Ä¢	‚úì Dashboard charts
‚Ä¢	‚úì Scan details modal
‚Ä¢	‚úì Impact stats
‚Ä¢	‚úì Responsive design
üéØ MILESTONE (Hour 16): All features complete, dashboard polished, ready for testing
‚ÄÉ
HOUR 16: FINAL INTEGRATION & TESTING
‚Ä¢	Merge everything to dev
‚Ä¢	Full end-to-end testing
‚Ä¢	Test all user flows
‚Ä¢	Fix blocking bugs only
‚Ä¢	Merge dev ‚Üí main
HOUR 16-18: Bug Fixes & Demo Prep
‚Ä¢	Create 5 test pages (phishing, policy, legit)
‚Ä¢	Record demo video (backup)
‚Ä¢	Write demo script
‚Ä¢	Practice demo 3x
‚Ä¢	Deploy backend to Render
‚Ä¢	Deploy dashboard to Vercel
HOUR 18-20: Final Polish & Presentation
‚Ä¢	Practice demo 5+ more times
‚Ä¢	Prepare for questions
‚Ä¢	Test on different browsers
‚Ä¢	Create pitch deck (7 slides)
‚Ä¢	Final team run-through
üéØ FINAL MILESTONE (Hour 20): Demo ready, deployed, practiced, confident!
‚ÄÉ
10. How to Avoid Merge Conflicts
The Golden Rules
‚Ä¢	1. ONLY edit files you own
‚Ä¢	2. Communicate before changing shared files
‚Ä¢	3. Pull dev before starting new work
‚Ä¢	4. Merge dev into your branch daily
‚Ä¢	5. Test your changes before creating PR
‚Ä¢	6. Keep commits small and frequent
Common Conflict Scenarios & Solutions
Scenario 1: contracts.py needs to change
Problem: Person B realizes they need to add a field to AnalystOutput

Solution:
1. Person B announces in Slack: "Need to add 'privacyScore' field to AnalystOutput"
2. Everyone agrees (or suggests alternative)
3. Person D makes the change to contracts.py
4. Everyone pulls latest dev
5. Everyone updates their code to use new field

DON'T: Edit contracts.py directly without team discussion
Scenario 2: MongoDB schema needs update
Problem: Person C needs to store user learning history

Solution:
1. Person C talks to Person D (owns database.py)
2. Person D adds new collection: learning_history
3. Person D creates helper function: save_learning_event()
4. Person C imports and uses the function

DON'T: Person C edit database.py directly
Scenario 3: Two people edit README.md
Problem: Person A and Person D both update README

Solution:
1. Designate Person D as README owner
2. Others submit suggestions via Slack
3. Person D makes all edits

Alternative:
1. Person A edits Extension section
2. Person D edits Backend section
3. Clear boundaries, no overlap
If You Get a Merge Conflict:
1. Don't panic!
2. Git will mark conflicts in files with <<<<<<< and >>>>>>>
3. Open the file and look for these markers
4. Decide which version to keep (or combine both)
5. Remove the conflict markers
6. Test that your code still works
7. git add <file>
8. git commit -m "fix: resolve merge conflict in X"
9. git push

If stuck, ask Person D for help!
‚ÄÉ
11. Demo Script (90 Seconds)
"Hi, I'm [Name]. This is Guardian AI - your digital bodyguard against 
online scams and privacy violations.

Let me show you how it works. I just received this suspicious email...
[Paste email text into extension]

Instant alert! Guardian's Scout agent detected urgency manipulation and a 
fake sender. Risk score: 92%. The Analyst agent confirmed this is phishing 
using the MITRE ATT&CK framework.

Now watch this - I visit a privacy policy page...
[Navigate to test T&C page]

Guardian auto-analyzed it in real-time. HIGH RISK. The Analyst extracted 
that they collect my location 24/7, sell data to 400+ advertisers, and I 
can't even delete it. The Educator agent translated all this legalese into 
plain English so I know exactly what I'm agreeing to.

But here's the really cool part - Guardian is predictive.
[Show dashboard trending warnings]

It's analyzing trending scams in MongoDB and warning me BEFORE I encounter 
them: 'Fake tax refund scams targeting Toronto residents this week.'

And we're not just protecting individuals - we're protecting communities.
[Point to dashboard stats]

342 users protected today. $12,450 in losses prevented this week. Each user 
who spots a threat helps protect others.

Guardian doesn't just block threats - it predicts them, explains them, and 
builds digital resilience. Thank you!"
‚ÄÉ
12. Winning Strategy & Prizes
Target Prizes:
‚Ä¢	ü•à Main 2nd Place (Espresso Machine) - PRIMARY TARGET
‚Ä¢	üèÜ MongoDB Prize (M5GO Kit) - VERY STRONG (showcase usage)
‚Ä¢	üèÜ ElevenLabs Prize (Earbuds) - STRONG (voice alerts)
Why This Team Structure Wins:
‚Ä¢	‚úÖ Everyone can speak to AI usage (all used Gemini)
‚Ä¢	‚úÖ Clear technical depth (MITRE ATT&CK shows professionalism)
‚Ä¢	‚úÖ 3 unique features competitors won't have
‚Ä¢	‚úÖ Perfect Security pillar alignment
‚Ä¢	‚úÖ Strong MongoDB usage (predictive threats + user patterns)
‚Ä¢	‚úÖ Real social impact (protects vulnerable populations)
‚Ä¢	‚úÖ Team demonstrates collaboration (4 agents working together)
What to Emphasize in Presentation:
‚Ä¢	1. Security pillar: "Protecting users from scams and privacy violations"
‚Ä¢	2. Unique email/message scanning: "Not just web pages - ANY suspicious text"
‚Ä¢	3. Privacy transparency: "Explains T&C in plain English"
‚Ä¢	4. Predictive protection: "Warns BEFORE threats appear"
‚Ä¢	5. MITRE ATT&CK: "Professional-grade threat classification"
‚Ä¢	6. MongoDB usage: "Trending threats, user patterns, community protection"
‚Ä¢	7. Community impact: "342 users protected, $12K saved"
Final Pre-Demo Checklist:
‚Ä¢	‚úì All 4 agents working independently
‚Ä¢	‚úì Full pipeline tested (extension ‚Üí backend ‚Üí dashboard)
‚Ä¢	‚úì Email paste scanning works
‚Ä¢	‚úì Privacy policy analyzer works
‚Ä¢	‚úì WebSocket alerts showing in dashboard
‚Ä¢	‚úì Voice alerts enabled (for ElevenLabs prize)
‚Ä¢	‚úì MongoDB queries for trending threats working
‚Ä¢	‚úì Demo practiced 10+ times
‚Ä¢	‚úì Everyone can explain their agent
‚Ä¢	‚úì Emphasis on SECURITY pillar throughout
üöÄ GO BUILD WITH YOUR TEAM! üõ°Ô∏è
Each person owns one agent. Everyone learns AI. No conflicts. Perfect collaboration.
